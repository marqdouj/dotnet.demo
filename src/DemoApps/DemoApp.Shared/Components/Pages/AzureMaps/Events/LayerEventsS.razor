@inject ILogger<LayerEventsS> Logger
@inject IToastService ToastService
@inject IMapDataService DataService

<PageTitle>Layer Events</PageTitle>

<FluentLayout>
    <MapPageHeader Header="Layer Events" LayerDef="@null" HRefSource="@hRefSource">
        <FluentLabel>
            This example demonstrates dynamically adding/removing layer (and it's DataSource ) events.
            <br /><br />
            When a subscribed event is fired a notification will be written to the <CodeText>Console</CodeText>
            and the last 20 events to the <CodeText>Event Viewer</CodeText> below the map.
            <br />
            NOTE: 'PreventDefault' is set to 'true' for all layer events (where applicable).
            <br /><br />
            Use the "Reset Map" button to reset the map to its initial state.
        </FluentLabel>
    </MapPageHeader>

    <FluentToolbar>
        <FluentButton IconStart="@(new Icons.Regular.Size20.ArrowReset())" Title="Reset Map" OnClick="@ResetMap" />
        <FluentSpacer Width="10" />
        <FluentLabel>Events:</FluentLabel>
        <FluentButton IconStart="@(new Icons.Regular.Size20.CheckboxChecked())" Title="Subscribe" OnClick="@(() => SelectAllEvents(true))" />
        <FluentButton IconStart="@(new Icons.Regular.Size20.CheckboxUnchecked())" Title="Unsubscribe" OnClick="@(() => SelectAllEvents(false))" />
        <FluentSpacer Width="10" />
        <FluentCheckbox @bind-Value:get="@layerLoaded" @bind-Value:set="OnLayerCheckedChanged">Add/Remove Layer</FluentCheckbox>
    </FluentToolbar>

    <FluentStack Orientation="Orientation.Vertical">
        <FluentStack>
            <FluentCard Height="@mapHeight" Width="300px" Style="overflow:auto">
                <div>
                    <FluentStack Orientation="Orientation.Vertical">
                        @foreach (var item in layerEvents)
                        {
                            <FluentCheckbox @bind-Value:get="@item.IsChecked" @bind-Value:set="@((e) => OnMapEventsCheckedChanged(e, item.Type))">@item.Name</FluentCheckbox>
                        }
                    </FluentStack>
                </div>

            </FluentCard>
            <FluentCard Height="@mapHeight" Width="@mapWidth">
                <AzureMap Id="@mapId"
                          OnMapEventAny="@OnMapEventAny"
                          Controls="@MapHelpers.GetDefaultControls()"
                          OnMapReady="@OnMapReady"
                          Options="@MapHelpers.GetDefaultCreateMapOptions()" />
            </FluentCard>
        </FluentStack>
        <FluentLabel>Marker Events:</FluentLabel>
        <EventViewer Events="@events" />
    </FluentStack>
</FluentLayout>


@code {
    private string hRefSource => nameof(LayerEventsS).ToMapEventsPageSource();
    private IAzureMapContainer? mapContainer;
    private string mapHeight = "300px";
    private string mapWidth = "100%";
    private string mapId = "layerEvents"; //Optional; used here in demo to shorten the Id when wrting to the Console.
    private List<MapEventArgsViewModel> events = new();
    private readonly List<MapEventViewModel> layerEvents
        = MapEventTarget.Layer.GetMapEventDefs().Select(e => new MapEventViewModel(e)).ToList(); 
    private MapLayerDef? layerDef;
    private bool layerLoaded => layerDef != null;
    private bool layerNotLoaded => !layerLoaded;

    protected override void OnInitialized()
    {
        foreach (var item in layerEvents)
            item.EventDef.PreventDefault = true;
    }

    private async Task OnMapReady(IAzureMapContainer mapContainer)
    {
        try
        {
            await Task.CompletedTask;
            this.mapContainer = mapContainer;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, null);
            ToastService.Error(ex);
        }
    }

    private async Task ResetMap()
    {
        try
        {
            if (mapContainer == null) return;

            await SelectAllEvents(false);
            events.Clear();
            await RemoveLayer();
            await mapContainer.Configuration.SetMapOptions(MapHelpers.GetDefaultSetMapOptions());

        }
        catch (Exception ex)
        {
            Logger.LogError(ex, null);
            ToastService.Error(ex);
        }
    }

    private async Task OnMapEventAny(MapEventArgs args)
    {
        try
        {
            events.Insert(0, new MapEventArgsViewModel(args));
            if (events.Count > 20)
                events = events.Take(20).ToList();

            Console.WriteLine($"OnMapEventAny: {args}");
            Console.WriteLine();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, null);
            ToastService.Error(ex);
        }
    }

    private async Task SelectAllEvents(bool selected)
    {
        try
        {
            foreach (var item in layerEvents)
                item.IsChecked = selected;

            await SubscribeEvents();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, null);
            ToastService.Error(ex);
        }
    }

    private async Task SubscribeEvents()
    {
        if (layerLoaded)
        {
            var unSubscribed = layerEvents.Where(e => e.IsChecked && e.IsNotLoaded).ToList();
            await mapContainer!.Maps.AddEvents(unSubscribed.Select(e => e.EventDef));

            foreach (var item in unSubscribed)
                item.IsLoaded = true;

            var subscribed = layerEvents.Where(e => e.IsNotChecked && e.IsLoaded).ToList();
            await mapContainer!.Maps.RemoveEvents(subscribed.Select(e => e.EventDef));

            foreach (var item in subscribed)
                item.IsLoaded = false;
        }
    }

    private async Task OnMapEventsCheckedChanged(bool value, MapEventType? type)
    {
        try
        {
            var item = layerEvents.First(e => e.Type == type);
            item.IsChecked = value;

            await SubscribeEvents();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, null);
            ToastService.Error(ex);
        }
    }

    private async Task OnLayerCheckedChanged(bool value)
    {
        try
        {
            if (value == layerLoaded)
                return;

            if (value)
            {
                await AddLayer();
            }
            else
            {
                await RemoveLayer();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, null);
            ToastService.Error(ex);
        }
    }

    private async Task AddLayer(MapLayerType layerType = MapLayerType.Symbol)
    {
        try
        {
            if (mapContainer == null) return;

            var subscribed = layerEvents.Where(e => e.IsChecked).ToList();
            layerDef = await mapContainer.AddBasicMapLayer(DataService, await layerType.GetDefaultLayerDef(DataService), subscribed.Select(e => e.EventDef));
            foreach (var item in subscribed)
                item.IsLoaded = true;
            foreach (var item in layerEvents)
                item.EventDef.TargetId = layerDef.Id;

        }
        catch (Exception ex)
        {
            Logger.LogError(ex, null);
            ToastService.Error(ex);
        }
    }

    private async Task RemoveLayer()
    {
        if (mapContainer == null)
            return;

        if (layerDef != null)
        {
            await mapContainer.Layers.RemoveLayer(layerDef);
            layerDef = null;

            foreach (var item in layerEvents)
                item.IsLoaded = false;
        }
    }
}
