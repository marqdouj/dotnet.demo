@using DemoApp.Shared.Models.AzureMaps
@using Marqdouj.DotNet.AzureMaps
@using Marqdouj.DotNet.AzureMaps.Map.Events
@using Marqdouj.DotNet.AzureMaps.Map.Interop
@using Marqdouj.DotNet.AzureMaps.Map.Layers
@inject ILogger<MapEventsS> Logger
@inject IToastService ToastService
@inject IMapDataService DataService

<PageTitle>Map Events</PageTitle>

<FluentLayout>
    <MapPageHeader Header="Map Events" LayerDef="@null" HRefSource="@hRefSource">
        <FluentLabel>
            This example demonstrates dynamically adding/removing map events.
            <br /><br />
            When a subscribed event is fired a notification will be written to the <CodeText>Console</CodeText>
            and the last 20 events to the <CodeText>Event Viewer</CodeText> below the map.
            <br /><br />
            Use the "Reset Map" button to reset the map to its initial state.
        </FluentLabel>
    </MapPageHeader>

    <FluentToolbar>
        <FluentButton IconStart="@(new Icons.Regular.Size20.ArrowReset())" Title="Reset Map" OnClick="@ResetMap" />
        <FluentSpacer Width="10"/>
        <FluentLabel>Events:</FluentLabel>
        <FluentButton IconStart="@(new Icons.Regular.Size20.CheckboxChecked())" Title="Subscribe" OnClick="@(() => SelectAllEvents(true))" />
        <FluentButton IconStart="@(new Icons.Regular.Size20.CheckboxUnchecked())" Title="Unsubscribe" OnClick="@(() => SelectAllEvents(false))" />
        <FluentSpacer Width="10" />
        <FluentCheckbox @bind-Value:get="@layerLoaded" @bind-Value:set="OnLayerCheckedChanged">Add/Remove Layer</FluentCheckbox>
    </FluentToolbar>

    <FluentStack Orientation="Orientation.Vertical">
        <FluentStack>
            <FluentCard Height="@mapHeight" Width="300px" Style="overflow:auto">
                <div>
                    <FluentStack Orientation="Orientation.Vertical">
                        @foreach (var item in mapEvents)
                        {
                            <FluentCheckbox @bind-Value:get="@item.IsLoaded" @bind-Value:set="@((e) => OnMapEventsCheckedChanged(e, item.Type))">@item.Name</FluentCheckbox>
                        }
                    </FluentStack>
                </div>

            </FluentCard>
            <FluentCard Height="@mapHeight" Width="@mapWidth">
                <AzureMap Id="@mapId"
                          OnMapEventAny="@OnMapEventAny"
                          Controls="@MapHelpers.GetDefaultControls()"
                          OnMapReady="@OnMapReady"
                          Options="@MapHelpers.GetDefaultCreateMapOptions()" />
            </FluentCard>
        </FluentStack>
        <FluentLabel>Marker Events:</FluentLabel>
        <EventViewer Events="@events" />
    </FluentStack>
</FluentLayout>


@code {
    private string hRefSource => nameof(MapEventsS).ToMapEventsPageSource();
    private IAzureMapContainer? mapContainer;
    private string mapHeight = "300px";
    private string mapWidth = "100%";
    private string mapId = "mapEvents"; //Optional; used here in demo to shorten the Id when wrting to the Console.
    private List<MapEventArgsViewModel> events = new();
    private readonly List<MapEventViewModel> mapEvents 
        = MapEventTarget.Map.GetMapEventDefs().Select(e => new MapEventViewModel(e)).ToList();
    private MapLayerDef? layerDef;
    private bool layerLoaded => layerDef != null;

    protected override void OnInitialized()
    {
        //remove for now in this demo.
        mapEvents.Remove(mapEvents.First(e => e.Type == MapEventType.MapConfigurationChanged));
        mapEvents.Remove(mapEvents.First(e => e.Type == MapEventType.TokenAcquired));
    }

    private async Task OnMapReady(IAzureMapContainer mapContainer)
    {
        try
        {
            await Task.CompletedTask;
            this.mapContainer = mapContainer;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, null);
            ToastService.Error(ex);
        }
    }

    private async Task ResetMap()
    {
        try
        {
            if (mapContainer == null) return;

            await SelectAllEvents(false);
            events.Clear();
            await RemoveLayer();
            await mapContainer.Configuration.SetMapOptions(MapHelpers.GetDefaultSetMapOptions());

        }
        catch (Exception ex)
        {
            Logger.LogError(ex, null);
            ToastService.Error(ex);
        }
    }

    private async Task OnMapEventAny(MapEventArgs args)
    {
        try
        {
            events.Insert(0, new MapEventArgsViewModel(args));
            if (events.Count > 20)
                events = events.Take(20).ToList();

            Console.WriteLine($"OnMapEventAny: {args}");
            Console.WriteLine();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, null);
            ToastService.Error(ex);
        }
    }

    private async Task SelectAllEvents(bool selected)
    {
        try
        {
            if (selected)
            {
                var unSubscribed = mapEvents.Where(e => e.IsNotLoaded).Select(e => e.EventDef);
                await mapContainer!.Maps.AddEvents(unSubscribed);
            }
            else
            {
                var subscribed = mapEvents.Where(e => e.IsLoaded).Select(e => e.EventDef);
                await mapContainer!.Maps.RemoveEvents(subscribed);
            }

            foreach (var item in mapEvents)
                item.IsLoaded = selected;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, null);
            ToastService.Error(ex);
        }
    }

    private async Task OnMapEventsCheckedChanged(bool value, MapEventType? type)
    {
        try
        {
            var item = mapEvents.First(e => e.Type == type);
            if (item.IsLoaded == value)
                return;

            if (value)
            {
                await mapContainer!.Maps.AddEvents(new List<MapEventDef> { item.EventDef });
            }
            else
            {
                await mapContainer!.Maps.RemoveEvents(new List<MapEventDef> { item.EventDef });
            }

            item.IsLoaded = value;

        }
        catch (Exception ex)
        {
            Logger.LogError(ex, null);
            ToastService.Error(ex);
        }
    }

    private async Task OnLayerCheckedChanged(bool value)
    {
        try
        {
            if (value == layerLoaded)
                return;

            if (value)
            {
                await OnMapEventsCheckedChanged(true, MapEventType.SourceAdded);
                await OnMapEventsCheckedChanged(true, MapEventType.SourceRemoved);
                await OnMapEventsCheckedChanged(true, MapEventType.LayerAdded);
                await OnMapEventsCheckedChanged(true, MapEventType.LayerRemoved);
                await AddLayer();
            }
            else
            {
                await RemoveLayer();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, null);
            ToastService.Error(ex);
        }
    }

    private async Task AddLayer(MapLayerType layerType = MapLayerType.Symbol)
    {
        try
        {
            if (mapContainer == null) return;
            
            layerDef = await mapContainer.AddBasicMapLayer(DataService, await layerType.GetDefaultLayerDef(DataService));
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, null);
            ToastService.Error(ex);
        }
    }

    private async Task RemoveLayer()
    {
        if (mapContainer == null)
            return;

        if (layerDef != null)
        {
            await mapContainer.Layers.RemoveLayer(layerDef);
            layerDef = null;
        }
    }
}
