@using DemoApp.Shared.Models.AzureMaps
@using Marqdouj.DotNet.AzureMaps
@using Marqdouj.DotNet.AzureMaps.Map.GeoJson
@using Marqdouj.DotNet.AzureMaps.Map.Geolocation
@using Marqdouj.DotNet.AzureMaps.Map.Interop
@using Marqdouj.DotNet.AzureMaps.Map.Layers
@using Marqdouj.DotNet.AzureMaps.Map.Layers.Managers
@using Marqdouj.DotNet.AzureMaps.UI.Services
@inject ILogger<MultipleLayersS> Logger
@inject IToastService ToastService
@inject IDialogService DialogService
@inject IMapDataService DataService
@inject IAzureMapsXmlService XmlService

<PageTitle>Layers</PageTitle>

<FluentLayout>
	<MapPageHeader Header="Layers" LayerDef="null" HRefSource="@hRefSource" @bind-ShowNarrative="@showNarrative">
		<FluentLabel>
			<FluentLabel>
				This example demonstrates managing a collection of layers.
				<br /><br />
				The <CodeText>GeolocationManager</CodeText> is used to manage the layers for adding the user's current geolocation.
				<br />
				Support has been added for Stop/Start Geolocation Watch.
			</FluentLabel>
			<br />
		</FluentLabel>
	</MapPageHeader>

	<FluentToolbar>
		<FluentButton Disabled="@disabled" IconStart="@(new Icons.Regular.Size20.ArrowReset())" Title="Reset Map" OnClick="@ResetMap" />
		<FluentSpacer Width="8" />
		<FluentButton Disabled="@disabledGetLocation" IconStart="@(new Icons.Regular.Size20.GlobeSearch())" Title="Get Current Location" OnClick="@GetCurrentPosition" />
		<FluentSpacer Width="3" />
		<FluentButton Disabled="@disabledWatching" IconStart="@(new Icons.Regular.Size20.EyeTracking())" Title="Start Watch" OnClick="@(() => GeolocationWatch(true))" />
		<FluentButton Disabled="@disabledNotWatching" IconStart="@(new Icons.Regular.Size20.EyeTrackingOff())" Title="Stop Watch" OnClick="@(() => GeolocationWatch(false))" />
	</FluentToolbar>

	<FluentStack>
		<FluentCard Height="@mapHeight" Width="300px" Style="overflow:auto">
			<div>
				<FluentStack Orientation="Orientation.Vertical">
					@foreach (var vm in mapLayers)
					{
						<FluentStack>
							<FluentCheckbox Disabled="@disabled" @bind-Value:get="@vm.IsLoaded" @bind-Value:set="@(e => OnCheckedChanged(e, vm.LayerDef.LayerType))">@vm.LayerDef.LayerType</FluentCheckbox>
							@if (vm.ZoomTo != null)
							{
								<FluentButton Disabled="@vm.IsNotLoaded" IconStart="@(new Icons.Regular.Size20.ZoomIn())" Title="Zoom To" OnClick="@(() => ZoomToLayer(vm))" />
							}
						</FluentStack>
					}
				</FluentStack>
			</div>

		</FluentCard>
		<FluentCard Height="@mapHeight" Width="@mapWidth">
			<AzureMap Height="@mapHeight"
					  Width="@mapWidth"
					  Controls="@MapHelpers.GetDefaultControls()"
					  OnMapReady="@OnMapReady"
					  OnGeolocationWatch="@OnGeolocationWatch"
					  Options="@MapHelpers.GetDefaultCreateMapOptions()" />
		</FluentCard>
	</FluentStack>
</FluentLayout>

<FluentOverlay @bind-Visible="@overlay"
			   Transparent="false">
	<FluentProgressRing />
</FluentOverlay>

@code {
	private bool overlay;
	private bool showNarrative = true;
	private bool showNarrativeFirstTime = true;
	private bool disabled => overlay || mapContainer == null;
	private string hRefSource => nameof(MultipleLayersS).ToMapPageSource();
	private string mapHeight = "400px";
	private string mapWidth = "100%";
	private IAzureMapContainer? mapContainer;
	private List<MapLayerViewModel> mapLayers = new();
	private readonly GeolocationManager geolocationManager = new();
	private bool isWatching;
	private bool isNotWatching => !isWatching;
	private bool disabledWatching => disabled || isWatching;
	private bool disabledNotWatching => disabled || isNotWatching;
	private bool disabledGetLocation => disabled || isWatching;

	protected override async Task OnInitializedAsync()
	{
		mapLayers = await LayerExtensions.GetLayerViewModels(DataService);
	}

	private async Task OnMapReady(IAzureMapContainer mapContainer)
	{
		try
		{
			await Task.CompletedTask;
			this.mapContainer = mapContainer;
		}
		catch (Exception ex)
		{
			Logger.LogError(ex, null);
			ToastService.Error(ex);
		}
	}

	private async Task ResetMap()
	{
		try
		{
			if (mapContainer == null) return;

			await geolocationManager.RemoveLayers(mapContainer);

			if (!mapLayers.Any()) return;

			await mapContainer.Layers.RemoveLayers(mapLayers.Select(e => e.LayerDef));

			foreach (var layer in mapLayers)
				layer.IsLoaded = false;

			await mapContainer.Configuration.SetMapOptions(MapHelpers.GetDefaultSetMapOptions());
		}
		catch (Exception ex)
		{
			Logger.LogError(ex, null);
			ToastService.Error(ex);
		}
	}

	private async Task GetCurrentPosition()
	{
		try
		{
			if (mapContainer == null) return;

			overlay = true;

			var geolocation = await mapContainer.Maps.GetGeolocation(new PositionOptions { EnableHighAccuracy = true });

			if (geolocation != null)
			{
				if (geolocation.IsSuccess)
				{
					await UpdateGeolocation(geolocation);
				}
				else
				{
					var errMsg = $"Geolocation service failed. {geolocation.Error?.Message}";
					Logger?.LogError(errMsg);
					ToastService?.Error(errMsg);
				}
			}
			else
			{
				var warnMsg = $"Geolocation service returned null.";
				Logger?.LogWarning(warnMsg);
				ToastService?.Warning(warnMsg);
			}
		}
		catch (Exception ex)
		{
			Logger.LogError(ex, null);
			ToastService.Error(ex);
		}
		finally
		{
			overlay = false;
		}
	}

	private async Task ZoomToLayer(MapLayerViewModel vm)
	{
		try
		{
			if (mapContainer == null) return;
			if (!vm.IsLoaded) return;

			overlay = true;
			await mapContainer.Configuration.ZoomTo(vm.ZoomTo!, vm.ZoomLevel);
		}
		catch (Exception ex)
		{
			Logger.LogError(ex, null);
			ToastService.Error(ex);
		}
		finally
		{
			overlay = false;
		}
	}

	private async Task AddMapLayer(MapLayerViewModel vm)
	{
		try
		{
			if (mapContainer == null) return;

			overlay = true;

			_= await mapContainer.AddBasicMapLayer(DataService, vm.LayerDef);
			vm.IsLoaded = true;

			UpdateShowNarrative();
		}
		catch (Exception ex)
		{
			Logger.LogError(ex, null);
			ToastService.Error(ex);
		}
		finally
		{
			overlay = false;
		}
	}

	private void UpdateShowNarrative()
	{
		if (showNarrativeFirstTime)
		{
			showNarrativeFirstTime = false;
			showNarrative = false;
		}
	}

	private async Task OnCheckedChanged(bool value, MapLayerType type)
	{
		var vm = mapLayers.First(e => e.LayerDef.LayerType == type);

		if (value)
		{
			await AddMapLayer(vm);
		}
		else
		{
			await mapContainer!.Layers.RemoveLayer(vm.LayerDef);
			vm.IsLoaded = false;
		}
	}

	private async Task GeolocationWatch(bool watch)
	{
		try
		{
			if (mapContainer == null) return;
			if (watch && isWatching) return;
			if (!watch && isNotWatching) return;

			if (watch)
			{
				await geolocationManager.Clear(mapContainer);
				await mapContainer.Maps.WatchGeolocation();
				isWatching = true;
				ToastService.Info("Waiting for first Geolocation Watch event...");
			}
			else
			{
				await RemoveWatch();
			}
		}
		catch (Exception ex)
		{
			Logger.LogError(ex, null);
			ToastService.Error(ex);
		}
	}

	private async Task RemoveWatch()
	{
		try
		{
			if (mapContainer == null) return;
			if (isWatching)
			{
				await mapContainer.Maps.ClearWatchGeolocation();
				isWatching = false;
				await geolocationManager.Clear(mapContainer);
			}
		}
		catch (JSDisconnectedException)
		{
		}
	}

	private async Task OnGeolocationWatch(GeolocationEventArgs e)
	{
		ToastService.Info($"Geolocation Watch event received. Success:{e.GeolocationResult.IsSuccess}");
		if (e.GeolocationResult.IsSuccess)
		{
			await UpdateGeolocation(e.GeolocationResult);
		}
	}

	private async Task UpdateGeolocation(GeolocationResult geolocation)
	{
		if (mapContainer == null) return;

		var coordinates = geolocation.Position!.Coords!;
		var position = new Position(coordinates.Longitude, coordinates.Latitude) { Accuracy = geolocation.Position.Coords?.Accuracy };
		if (!geolocationManager.LayersAdded)
			await geolocationManager.AddLayers(mapContainer);
		await geolocationManager.Clear(mapContainer);
		await geolocationManager.AddPosition(mapContainer, position);
		await mapContainer.Configuration.ZoomTo(position, 15);
	}
}
