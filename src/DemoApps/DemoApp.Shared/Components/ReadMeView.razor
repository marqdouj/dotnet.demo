@using Markdig
@inject HttpClient Http
@inject IDemoConfiguration DemoConfiguration

<FluentCard MinimalStyle="true" Style="@height">
    <div class="markdown-body" style="overflow-y:auto;height:100%;width:100%;padding:10px;">
        @((MarkupString)htmlContent)
    </div>
</FluentCard>

@code {
    private string htmlContent = "";
    private string height => string.IsNullOrWhiteSpace(Height) ? "height:90%" : $"height:{Height}";

    [Parameter]
    public string? Height { get; set; }

    [Parameter, EditorRequired]
    public HRefRepository? Repository { get; set; }

    protected override async Task OnInitializedAsync()
    {
        if (Repository.HasValue)
        {
            var pipeline = new MarkdownPipelineBuilder().UseAdvancedExtensions().Build();
            var url = Repository.ReadMe();
            try
            {
                var markdownContent = await Http.GetStringAsync(url);
                var html = Markdown.ToHtml(markdownContent, pipeline);
                htmlContent = AddBlankTargetToAnchorTags(html);
            }
            catch (Exception ex)
            {
                if (DemoConfiguration.InDevelopment)
                {
                    htmlContent = ex.ToMessage();
                }
                else
                {
                    throw;
                }
            }
        }
    }

    private static string AddBlankTargetToAnchorTags(string content)
    {
        var result = content;
        var pStart = 0;
        var pEnd = 0;
        const string aStart = "<a href";
        const string aEnd = "</a>";
        const string hRefEnd = "\">";
        const string target = " target=\"_blank\"";
        List<AnchorValues> anchors = [];

        try
        {
            while (pStart > -1)
            {
                pStart = content.IndexOf(aStart, pEnd, StringComparison.OrdinalIgnoreCase);

                if (pStart > -1)
                {
                    pEnd = content.IndexOf(aEnd, pStart, StringComparison.OrdinalIgnoreCase);

                    if (pEnd == -1)
                        break;

                    var anchor = content.Substring(pStart, pEnd - pStart + aEnd.Length);

                    if (anchor.IndexOf(target, StringComparison.OrdinalIgnoreCase) == -1)
                    {
                        var pInsert = anchor.IndexOf(hRefEnd);
                        var a = anchor.Insert(pInsert + hRefEnd.Length - 1, target);
                        anchors.Add(new AnchorValues(anchor, a));
                    }

                    pStart = pEnd;
                }
            }

            foreach (var a in anchors)
            {
                result = result.Replace(a.Normal, a.Target);
            }
        }
        catch (Exception ex)
        {
            result = content;
            Console.WriteLine(ex.ToMessage());
        }

        return result;
    }

    private class AnchorValues (string normal, string target)
    {
        public string Normal { get; } = normal;
        public string Target { get; } = target;
    }
}
